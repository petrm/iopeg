#summary Strangities, niceties, etc from Io spelunking.
#labels IoLanguage

= Io Nuggets! =
{{{
foo := method( a1, "all done" println )
bar := method( "hello" println )
bad := method( "OH NOES!" println )
foo( bar, bad bad bad )
#=> hello
#=> all done
}}}
Any arguments not explicitly listed at method define time aren't executed during method dispatch. However, the full syntax tree of what you wrote for that parameter is totally intact. You can choose, inside the method, to eval the methods in whatever scope you want.

This is how select and map work in their shorthand forms, evaling the supplied code in another scope:
{{{
self foreach( v,
  doInContext(getSlot("v"), call sender)
  ...
)
}}}
----
{{{
foo := method( call activated call )
}}}
// Boom. I was trying for a strange infinite loop, and found a strange crash.
----
{{{
foo := method( call message protos first slotNames )
}}}
// Hmmmmmmm. This is cool. Some "unnamed" proto of Call objects has cool stuffs.
----
{{{
Directory with( launchPath ) items foreach(i,v,v name println)
}}}
// I'm a bit wary of 'stringing' so many calls together. But maybe that fear is invalid in Io.
----
This made me laugh, and smile:
"In case you were wondering, method is a method on Object that creates anonymous methods."
----

Random things that can be done with the regex library:
{{{
Io> s := "one!two!!three!!!"
==> one!two!!three!!!
Io> s splitAtRegex("!+")
==> list("one", "two", "three", "")
Io> s := "37signals"
==> 37signals
Io> s hasMatchOfRegex("signals")
==> true
Io> "one two three" allMatchesOfRegex("\\w+") map(asString println)
one
two
three
==> list("one", "two", "three")
}}}